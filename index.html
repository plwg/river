<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Notes</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        // Set theme on initial load
        if (localStorage.theme === 'dark' || (!('theme' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
            document.documentElement.classList.add('dark');
        } else {
            document.documentElement.classList.remove('dark');
        }
    </script>
    <style>
        body { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
        .focus-ring-mono:focus { --tw-ring-opacity: 1; --tw-ring-color: rgb(107 114 128 / var(--tw-ring-opacity)); }
        .dark .focus-ring-mono:focus { --tw-ring-color: rgb(161 161 170 / var(--tw-ring-opacity)); }
        .note-text { white-space: pre-wrap; }
        textarea { overflow-y: hidden; }
        .note-link, .note-tag { text-decoration: underline; text-decoration-color: rgba(37, 99, 235, 0.4); cursor: pointer; }
        .note-link { color: #2563eb; }
        .note-tag { color: #1d4ed8; }
        .note-link:hover, .note-tag:hover { text-decoration-color: rgba(37, 99, 235, 1); }
        .dark .note-link, .dark .note-tag { text-decoration-color: rgba(96, 165, 250, 0.4); }
        .dark .note-link { color: #60a5fa; }
        .dark .note-tag { color: #93c5fd; }
        .dark .note-link:hover, .dark .note-tag:hover { text-decoration-color: rgba(96, 165, 250, 1); }
        @keyframes highlight-fade { from { background-color: var(--highlight-bg); } to { background-color: transparent; } }
        .highlight-note { --highlight-bg: rgb(254 249 195 / 0.8); animation: highlight-fade 2s ease-out forwards; }
        .dark .highlight-note { --highlight-bg: rgb(250 204 21 / 0.3); }
    </style>
</head>
<body class="bg-zinc-100 dark:bg-zinc-900 text-zinc-800 dark:text-zinc-200">

    <div class="container mx-auto max-w-2xl px-4 py-8 md:py-12">
        <div class="mb-8">
            <div class="flex items-start space-x-2">
                <textarea 
                    id="note-input" 
                    rows="1"
                    class="flex-grow w-full p-3 bg-zinc-200 dark:bg-zinc-800 border border-transparent rounded-md focus:outline-none focus:bg-white dark:focus:bg-zinc-900 focus:ring-2 focus-ring-mono transition duration-200 resize-none"
                ></textarea>
                <button 
                    id="save-button" 
                    title="Save Note (Cmd+Enter)"
                    class="bg-zinc-800 dark:bg-zinc-200 text-zinc-100 dark:text-zinc-800 p-3 rounded-md hover:bg-zinc-900 dark:hover:bg-white focus:outline-none focus:ring-2 focus:ring-zinc-500 dark:focus:ring-zinc-400 focus:ring-offset-2 focus:ring-offset-zinc-100 dark:focus:ring-offset-zinc-900 transition-transform transform active:scale-95"
                >
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2.5" stroke="currentColor" class="w-6 h-6">
                      <path stroke-linecap="round" stroke-linejoin="round" d="m9 12.75 3 3m0 0 3-3m-3 3v-7.5" />
                    </svg>
                </button>
            </div>
        </div>
        <div id="notes-container" class="space-y-3"></div>
    </div>
    
    <div class="fixed bottom-4 left-4 flex items-center space-x-4">
        <button id="import-button" class="text-xs text-zinc-400 dark:text-zinc-500 hover:text-zinc-700 dark:hover:text-zinc-300">import</button>
        <button id="export-button" class="text-xs text-zinc-400 dark:text-zinc-500 hover:text-zinc-700 dark:hover:text-zinc-300">export</button>
        <input type="file" id="csv-file-input" accept=".csv" class="hidden">
    </div>

    <script>
        const noteInput = document.getElementById('note-input');
        const saveButton = document.getElementById('save-button');
        const notesContainer = document.getElementById('notes-container');
        const importButton = document.getElementById('import-button');
        const exportButton = document.getElementById('export-button');
        const csvFileInput = document.getElementById('csv-file-input');

        let allNotes = [];
        const NOTES_STORAGE_KEY = 'notesApp.notes';

        const getNotesFromStorage = () => {
            const notesJSON = localStorage.getItem(NOTES_STORAGE_KEY);
            return notesJSON ? JSON.parse(notesJSON) : [];
        };

        const saveNotesToStorage = (notes) => {
            notes.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
            localStorage.setItem(NOTES_STORAGE_KEY, JSON.stringify(notes));
        };

        const autoResizeTextarea = (element) => {
            element.style.height = 'auto';
            element.style.height = `${element.scrollHeight}px`;
        };

        const copyToClipboard = (text, element) => {
            const originalText = element.textContent;
            navigator.clipboard.writeText(text).then(() => {
                element.textContent = 'Copied!';
                setTimeout(() => { element.textContent = originalText; }, 1500);
            }).catch(err => console.error('Clipboard copy failed', err));
        };
        
        const escapeHTML = (str) => {
            const p = document.createElement('p');
            p.textContent = str;
            return p.innerHTML;
        };

        const formatNoteContent = (text) => {
            const noteIdPrefixes = new Map(allNotes.map(note => [note.id.substring(0, 8), note.id]));
            // Regex to find URLs, note IDs, and tags. The order is important for correct matching.
            const combinedRegex = /(https?:\/\/[^\s<>"'`]+)|#([a-f0-9]{8})(?!\w)|#(\w+)/g;
    
            let result = '';
            let lastIndex = 0;
            let match;

            // Use exec() in a loop to iterate over all matches, which allows us to process the text *between* matches.
            while ((match = combinedRegex.exec(text)) !== null) {
                // 1. Append and escape the plain text part before the current match.
                result += escapeHTML(text.substring(lastIndex, match.index));

                const matchedString = match[0];
                const url = match[1];
                const noteId = match[2];
                const tagName = match[3];

                // 2. Process and append the matched link/tag.
                if (url) {
                    // It's a URL. Create a clickable link.
                    result += `<a href="${url}" target="_blank" rel="noopener noreferrer" class="note-link">${escapeHTML(url)}</a>`;
                } else if (noteId) {
                    const fullId = noteIdPrefixes.get(noteId);
                    if (fullId) {
                        // It's a valid note ID. Create a link to jump to the note.
                        result += `<a class="note-link" data-note-id="${fullId}" title="Jump to note ${noteId}...">${matchedString}</a>`;
                    } else {
                        // Matched a potential note ID format, but it's not in our records. Treat as plain text.
                        result += escapeHTML(matchedString);
                    }
                } else if (tagName) {
                    // It's a tag. Create a filter link.
                    result += `<a class="note-tag" data-tag="${tagName}" title="Filter by #${tagName}">${matchedString}</a>`;
                }
                
                lastIndex = combinedRegex.lastIndex;
            }

            // 3. Append and escape any remaining plain text after the last match.
            if (lastIndex < text.length) {
                result += escapeHTML(text.substring(lastIndex));
            }

            return result;
        };

        const appendToInput = (text) => {
            const currentText = noteInput.value.trim();
            noteInput.value = currentText ? `${currentText} ${text}` : `${text} `;
            noteInput.focus();
            noteInput.dispatchEvent(new Event('input', { bubbles: true }));
        };

        const generateUniqueId = async () => {
            const timestamp = Date.now().toString();
            const randomNum = window.crypto.getRandomValues(new Uint32Array(1))[0];
            const dataToHash = `${timestamp}-${randomNum}`;
            const encoder = new TextEncoder();
            const data = encoder.encode(dataToHash);
            const hashBuffer = await window.crypto.subtle.digest('SHA-256', data);
            const hashArray = Array.from(new Uint8Array(hashBuffer));
            return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
        };

        const saveNote = async () => {
            const noteText = noteInput.value.trim();
            if (noteText) {
                const uniqueId = await generateUniqueId();
                const newNote = {
                    id: uniqueId,
                    text: noteText,
                    timestamp: new Date().toISOString()
                };
                allNotes.unshift(newNote);
                saveNotesToStorage(allNotes);
                // Keep text in input, just re-render the notes list
                filterAndRenderNotes();
            }
        };
        
        const updateNote = (noteId, newText) => {
            const noteIndex = allNotes.findIndex(note => note.id === noteId);
            if (noteIndex > -1) {
                allNotes[noteIndex].text = newText;
                allNotes[noteIndex].timestamp = new Date().toISOString();
                saveNotesToStorage(allNotes);
                filterAndRenderNotes();
            }
        };

        const deleteNote = (noteId) => {
            allNotes = allNotes.filter(note => note.id !== noteId);
            saveNotesToStorage(allNotes);
            filterAndRenderNotes();
        };

        const filterAndRenderNotes = () => {
            const searchTerms = noteInput.value.toLowerCase().trim().split(/\s+/).filter(Boolean);
            let notesToRender = allNotes;
            if (searchTerms.length > 0) {
                const matchingNotes = [];
                const nonMatchingNotes = [];
                allNotes.forEach(note => {
                    if (searchTerms.every(term => note.text.toLowerCase().includes(term))) {
                        matchingNotes.push(note);
                    } else {
                        nonMatchingNotes.push(note);
                    }
                });
                notesToRender = [...matchingNotes, ...nonMatchingNotes];
            }
            renderNotes(notesToRender);
        };
        
        const renderNotes = (notesToRender) => {
            notesContainer.innerHTML = ''; 
            const searchTerms = noteInput.value.toLowerCase().trim().split(/\s+/).filter(Boolean);

            if (allNotes.length === 0) { 
                notesContainer.innerHTML = '';
            } else if (notesToRender.length === 0 && searchTerms.length > 0) {
                notesContainer.innerHTML = `<div class="text-center py-10"><p class="text-zinc-500 dark:text-zinc-400">No notes match your search.</p></div>`;
            } else {
                notesToRender.forEach(noteData => {
                    const card = document.createElement('div');
                    card.id = `note-${noteData.id}`;
                    const isMatch = searchTerms.length === 0 || searchTerms.every(term => noteData.text.toLowerCase().includes(term));
                    let cardClasses = 'bg-white/50 dark:bg-zinc-800/50 p-4 rounded-md border border-zinc-200 dark:border-zinc-700 flex flex-col transition-opacity duration-300';
                    if (!isMatch) cardClasses += ' opacity-50';
                    card.className = cardClasses;
                    
                    const textP = document.createElement('p');
                    textP.className = 'note-text text-zinc-800 dark:text-zinc-200 break-words flex-grow';
                    textP.innerHTML = formatNoteContent(noteData.text);

                    const editInput = document.createElement('textarea');
                    editInput.className = 'w-full p-1 bg-zinc-200 dark:bg-zinc-700 border border-zinc-300 dark:border-zinc-600 rounded-md focus:outline-none focus:ring-1 focus-ring-mono hidden resize-none flex-grow dark:text-zinc-200';
                    editInput.value = noteData.text;
                    editInput.oninput = () => autoResizeTextarea(editInput);

                    const footerDiv = document.createElement('div');
                    footerDiv.className = 'flex justify-between items-center mt-3';
                    
                    const timeP = document.createElement('p');
                    timeP.className = 'text-xs text-zinc-400 dark:text-zinc-500';
                    
                    const localDate = new Date(noteData.timestamp);
                    const year = localDate.getFullYear();
                    const month = String(localDate.getMonth() + 1).padStart(2, '0');
                    const day = String(localDate.getDate()).padStart(2, '0');
                    const hours = String(localDate.getHours()).padStart(2, '0');
                    const minutes = String(localDate.getMinutes()).padStart(2, '0');
                    const seconds = String(localDate.getSeconds()).padStart(2, '0');
                    timeP.textContent = `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;

                    const shortId = noteData.id.substring(0, 8);
                    const hashIdButton = document.createElement('button');
                    hashIdButton.className = 'text-xs text-zinc-400 dark:text-zinc-500 hover:text-zinc-700 dark:hover:text-zinc-300 ml-4';
                    hashIdButton.textContent = `#${shortId}`;
                    hashIdButton.title = `Copy ID: #${shortId}`;
                    hashIdButton.onclick = () => copyToClipboard(`#${shortId}`, hashIdButton);

                    const timeAndIdContainer = document.createElement('div');
                    timeAndIdContainer.className = 'flex items-center';
                    timeAndIdContainer.append(timeP, hashIdButton);

                    const controlsDiv = document.createElement('div');
                    controlsDiv.className = 'flex items-center space-x-3';
                    ['ins', 'del', 'save', 'cancel'].forEach(label => {
                        const button = document.createElement('button');
                        button.textContent = label;
                        button.dataset.action = label;
                        let classes = 'text-xs ';
                        if (label === 'ins' || label === 'cancel') classes += 'text-zinc-500 dark:text-zinc-400 hover:text-zinc-800 dark:hover:text-zinc-200';
                        if (label === 'del') classes += 'text-red-500 hover:text-red-700 dark:hover:text-red-400';
                        if (label === 'save') classes += 'text-green-600 dark:text-green-500 hover:text-green-800 dark:hover:text-green-400 font-medium';
                        if (label === 'save' || label === 'cancel') classes += ' hidden';
                        button.className = classes;
                        controlsDiv.appendChild(button);
                    });

                    footerDiv.append(timeAndIdContainer, controlsDiv);
                    card.append(textP, editInput, footerDiv);
                    notesContainer.appendChild(card);

                    const toggleEditMode = (isEditing) => {
                        textP.classList.toggle('hidden', isEditing);
                        editInput.classList.toggle('hidden', !isEditing);
                        controlsDiv.querySelector("[data-action='ins']").classList.toggle('hidden', isEditing);
                        controlsDiv.querySelector("[data-action='del']").classList.toggle('hidden', isEditing);
                        controlsDiv.querySelector("[data-action='save']").classList.toggle('hidden', !isEditing);
                        controlsDiv.querySelector("[data-action='cancel']").classList.toggle('hidden', !isEditing);
                        if (isEditing) { autoResizeTextarea(editInput); editInput.focus(); editInput.select(); }
                    };
                    
                    controlsDiv.querySelector("[data-action='ins']").onclick = () => toggleEditMode(true);
                    controlsDiv.querySelector("[data-action='cancel']").onclick = () => { editInput.value = noteData.text; toggleEditMode(false); };
                    controlsDiv.querySelector("[data-action='save']").onclick = () => {
                        const newText = editInput.value.trim();
                        if (newText && newText !== noteData.text) { updateNote(noteData.id, newText); }
                        toggleEditMode(false);
                    };
                    controlsDiv.querySelector("[data-action='del']").onclick = () => deleteNote(noteData.id);
                    editInput.onkeydown = (e) => {
                        if (e.key === 'Enter' && (e.metaKey || e.ctrlKey)) { e.preventDefault(); controlsDiv.querySelector("[data-action='save']").click(); }
                        if (e.key === 'Escape') {
                            e.preventDefault();
                            e.stopPropagation(); // Prevent document listener from re-focusing main input
                            controlsDiv.querySelector("[data-action='cancel']").click();
                        }
                    };
                });
            }
        };

        const loadInitialNotes = () => {
            allNotes = getNotesFromStorage();
            filterAndRenderNotes();
        };

        const resetNoteInput = () => { 
            noteInput.value = ''; 
            autoResizeTextarea(noteInput);
            filterAndRenderNotes();
        };

        const escapeCSV = (str) => `"${(str || '').replace(/"/g, '""')}"`;

        const exportToCSV = () => {
            if (allNotes.length === 0) return alert('No notes to export.');
            const headers = 'id,timestamp,text';
            const rows = allNotes.map(note => [note.id, note.timestamp, note.text].map(escapeCSV).join(','));
            const csvContent = `${headers}\n${rows.join('\n')}`;
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = `notes_export_${new Date().toISOString().slice(0, 10)}.csv`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        };

        const importFromCSV = (event) => {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = (e) => {
                const text = e.target.result;
                
                // A robust CSV parser to handle newlines and quotes.
                const parseCSV = (csvText) => {
                    const rows = [];
                    if (!csvText) return rows;

                    let fields = [];
                    let field = '';
                    let inQuotes = false;
                    // Normalize newlines and add a trailing newline to ensure the last row is processed.
                    const content = csvText.replace(/\r\n/g, '\n').trim() + '\n';

                    for (let i = 0; i < content.length; i++) {
                        const char = content[i];
                        
                        if (inQuotes) {
                            if (char === '"') {
                                // Check for escaped quote
                                if (i + 1 < content.length && content[i+1] === '"') {
                                    field += '"';
                                    i++; // Skip the second quote of the pair
                                } else {
                                    inQuotes = false;
                                }
                            } else {
                                field += char;
                            }
                        } else {
                            if (char === '"') {
                                inQuotes = true;
                            } else if (char === ',') {
                                fields.push(field);
                                field = '';
                            } else if (char === '\n') {
                                fields.push(field);
                                rows.push(fields);
                                fields = [];
                                field = '';
                            } else {
                                field += char;
                            }
                        }
                    }
                    return rows;
                };

                const allRows = parseCSV(text);

                if (allRows.length < 1) return alert('CSV file is empty or invalid.');
                
                const header = allRows.shift();
                
                const [idIdx, tsIdx, textIdx] = ['id', 'timestamp', 'text'].map(h => header.indexOf(h));

                if ([idIdx, tsIdx, textIdx].includes(-1)) {
                    return alert('Invalid CSV. Header must contain "id", "timestamp", and "text" columns.');
                }
                
                let updated = 0, added = 0;
                const notesMap = new Map(allNotes.map(n => [n.id, n]));

                for (const values of allRows) {
                    if (values.length !== header.length) continue; // Skip malformed rows

                    const id = values[idIdx];
                    const timestamp = values[tsIdx];
                    const noteText = values[textIdx];

                    if (!id || !timestamp || typeof noteText === 'undefined') continue;

                    const existing = notesMap.get(id);
                    if (existing) {
                        if (new Date(timestamp) > new Date(existing.timestamp)) {
                            existing.text = noteText;
                            existing.timestamp = timestamp;
                            updated++;
                        }
                    } else {
                        notesMap.set(id, { id, timestamp, text: noteText });
                        added++;
                    }
                }
                allNotes = Array.from(notesMap.values());
                saveNotesToStorage(allNotes);
                filterAndRenderNotes();
                alert(`Import complete. Added: ${added}, Updated: ${updated}.`);
            };
            reader.readAsText(file);
            event.target.value = '';
        };

        notesContainer.addEventListener('click', (e) => {
            const target = e.target;
            if (target.classList.contains('note-link') && target.dataset.noteId) {
                e.preventDefault();
                const noteId = target.dataset.noteId;
                const targetNote = document.getElementById(`note-${noteId}`);
                if (targetNote) {
                    targetNote.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    targetNote.classList.remove('highlight-note');
                    void targetNote.offsetWidth; 
                    targetNote.classList.add('highlight-note');
                }
            } else if (target.classList.contains('note-tag')) {
                e.preventDefault();
                appendToInput(`#${target.dataset.tag}`);
            }
        });

        saveButton.addEventListener('click', saveNote);
        noteInput.addEventListener('input', () => {
            autoResizeTextarea(noteInput);
            filterAndRenderNotes();
        });
        noteInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && (e.metaKey || e.ctrlKey)) { e.preventDefault(); saveNote(); }
            if (e.key === 'Escape') {
                e.preventDefault();
                resetNoteInput();
            }
        });
        exportButton.addEventListener('click', exportToCSV);
        importButton.addEventListener('click', () => csvFileInput.click());
        csvFileInput.addEventListener('change', importFromCSV);

        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                const activeEl = document.activeElement;
                // If focus is not on a textarea (either main input or edit input), focus the main input.
                if (activeEl && activeEl.tagName !== 'TEXTAREA') {
                    e.preventDefault();
                    noteInput.focus();
                }
            }
        });

        // Initial load
        loadInitialNotes();
    </script>
</body>
</html>


